import org.codehaus.groovy.grails.commons.ConfigurationHolder as CH

import groovy.xml.StreamingMarkupBuilder
import org.springframework.core.io.support.PathMatchingResourcePatternResolver

// http://www.liferay.com/documentation/liferay-portal/6.0/development/-/ai/anatomy-of-a-portlet

// Those jars are loaded at parents classloaders, 
// and causes silent portlet deployment failure if included.
eventCreateWarStart = { warName, stagingDir ->
   ant.delete(failonerror: false) {
      fileset(dir: "${stagingDir}/WEB-INF/lib") {
         include(name: "servlet-api*.jar")
         include(name: "portal-kernel*.jar")
         include(name: "portal-service*.jar")
         include(name: "portlet-api*.jar")
         include(name: "jcl-over-slf4j*.jar")
         include(name: "ord.spring*3.0*.jar") // Already in LR 6
      }
   }
}

// Add portlet's xmls
eventPackagingEnd = {
   def searchPath = "file:${basedir}/grails-app/portlets/**/*Portlet.groovy"
   def portletFiles = resolveResources(searchPath).toList()
   generateLiferayDisplayXml(portletFiles)
   generateLiferayPortletXml(portletFiles)
   generateLiferayPluginPackageProperties()
}

def resolveResources(String pattern) {
   def resolver = new PathMatchingResourcePatternResolver()
   return resolver.getResources(pattern)
}

def generateLiferayDisplayXml(portletFiles) {
   def liferayDisplayXml = new File("${basedir}/web-app/WEB-INF/liferay-display.xml")
   if (liferayDisplayXml.exists()) liferayDisplayXml.delete()
   def xmlWriter = new StreamingMarkupBuilder()

   def xml = xmlWriter.bind {
      mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>'
      mkp.yieldUnescaped '<!DOCTYPE display PUBLIC "-//Liferay//DTD Display 5.1.0//EN" "http://www.liferay.com/dtd/liferay-display_5_1_0.dtd">'
      mkp.comment 'GENERATED BY GRAILS PORTLETS PLUGIN - DO NOT EDIT AND CONFIGURE IN PORTLET groovy'

      def portletMap = [:]
      portletFiles.each {portletClassFile ->
         def className = getPortletClassName(portletClassFile.file.absolutePath)
         Class portletClass = classLoader.loadClass(className)
         def portletName = portletClassFile.filename - 'Portlet.groovy'
         def instance = portletClass.newInstance()
         if (hasProperty('liferay_display_category', instance)) {
            portletMap[instance.liferay_display_category] = [portletName] + (portletMap[instance.liferay_display_category] ?: [])
         }
      }

      'display' {
         portletMap.each { k, v ->
            'category'(name: k) {
               v.each { p ->
                  'portlet'(id: p)
               }
            }
         }
      }
   }
   liferayDisplayXml.write(xml.toString())
}

def generateLiferayPortletXml(portletFiles) {

   def mappers = [:]
   if (CH.config.liferay.portlet_role_mappers != null) {
      mappers = CH.config.liferay.portlet_role_mappers
      assert (mappers instanceof Map)
   } else {
      mappers = ['administrator': 'Administrator', 'guest': 'Guest', 'power-user': 'Power User', 'user': 'User']
   }

   def attribs = [:]
   if (CH.config.liferay.portlet_custom_user_attributes != null) {
      attribs = CH.config.liferay.portlet_custom_user_attributes
      assert (attribs instanceof Map)
   }

   def liferayPortletXml = new File("${basedir}/web-app/WEB-INF/liferay-portlet.xml")
   if (liferayPortletXml.exists()) liferayPortletXml.delete()
   def xmlWriter = new StreamingMarkupBuilder()
   def xml = xmlWriter.bind {
      mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>'
      mkp.yieldUnescaped '<!DOCTYPE liferay-portlet-app PUBLIC "-//Liferay//DTD Portlet Application 5.1.0//EN" "http://www.liferay.com/dtd/liferay-portlet-app_5_1_0.dtd">'
      mkp.comment 'GENERATED BY GRAILS PORTLETS LIFERAY PLUGIN - DO NOT EDIT THIS FILE.'
      'liferay-portlet-app' {
         portletFiles.each {portletClassFile ->
            def className = getPortletClassName(portletClassFile.file.absolutePath)
            Class portletClass = classLoader.loadClass(className)
            def portletName = portletClassFile.filename - 'Portlet.groovy'
            def instance = portletClass.newInstance()
            'portlet' {
               'portlet-name'(portletName)
               def fields = portletClass.getDeclaredFields()
               def dtd_portlet = [
                  'icon', 'virtual_path', 'struts_path',
                  'configuration_path', 'configuration_action_class', 'indexer_class',
                  'open_search_class', 'scheduler_class', 'portlet_url_class',
                  'friendly_url_mapper_class', 'url_encoder_class', 'portlet_data_handler_class',
                  'portlet_layout_listener_class', 'pop_message_listener_class',
                  'social_activity_interpreter_class', 'social_request_interpreter_class',
                  'preferences_company_wide', 'preferences_unique_per_layout',
                  'preferences_owned_by_group', 'use_default_template', 'show_portlet_access_denied',
                  'show_portlet_inactive', 'action_url_redirect', 'restore_current_view',
                  'maximize_edit', 'maximize_help', 'pop_up_print', 'layout_cacheable', 'instanceable',
                  'user_principal_strategy', 'private_request_attributes',
                  'private_session_attributes', 'render_weight', 'ajaxable', 'header_portal_css',
                  'header_portlet_css', 'header_portal_javascript', 'header_portlet_javascript',
                  'footer_portal_css', 'footer_portlet_css', 'footer_portal_javascript',
                  'footer_portlet_javascript', 'css_class_wrapper', 'facebook_integration',
                  'add_default_resource', 'system', 'active', 'include']

               dtd_portlet.each { elementName ->
                  def field = fields.find {
                     it.name == 'liferay_portlet_' + elementName
                  }
                  if (field) {
                     field.setAccessible(true)
                     def element = (field.name - 'liferay_portlet_').replace('_', '-')
                     if (field.get(instance) instanceof List) {
                        field.get(instance).each {
                           invokeMethod(element, it.toString())
                        }
                     } else {
                        invokeMethod(element, field.get(instance).toString())
                     }
                  }
               }
            }
         }
         mappers.each { role ->
            'role-mapper' {
               'role-name'(role.key)
               'role-link'(role.value)
            }
         }
         attribs.each { attrib ->
            'custom-user-attribute' {
               'name'(attrib.key)
               'custom-class'(attrib.value)
            }
         }
      }
   }
   liferayPortletXml.write(xml.toString())
}

def generateLiferayPluginPackageProperties() {
   def liferayPluginPackageProperties = new File("${basedir}/web-app/WEB-INF/liferay-plugin-package.properties")
   if (liferayPluginPackageProperties.exists()) {
      liferayPluginPackageProperties.delete()
   }
   if (CH.config.liferay.get('plugin_package') != null) {
      def conf = CH.config.liferay.get('plugin_package')
      def rconf = new ConfigObject()
      conf.each {key, value ->
         rconf += [(key.replace('_', '-')): (value)]
      }
      rconf.toProperties().store(liferayPluginPackageProperties.newOutputStream(),
         "This is generated by Grails. The changes will be overwritten. Edit 'liferay.grails-app/conf/Config.groovy.")
   }
}

def hasProperty(propertyName, instance) {
   try {
      def value = instance."${propertyName}"
      return true;
   } catch (MissingPropertyException mpe) {
      return false;
   }
}

def getPortletClassName(String filePath) {
   def withoutBasePath = filePath.substring("$basedir/grails-app/portlets".length() + 1)
   withoutBasePath.replaceAll('[\\\\/]', '.') - '.groovy'
}
