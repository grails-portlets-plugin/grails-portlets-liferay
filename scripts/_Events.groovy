import groovy.xml.StreamingMarkupBuilder

import org.springframework.core.io.Resource
import org.springframework.core.io.support.PathMatchingResourcePatternResolver

// http://www.liferay.com/documentation/liferay-portal/6.0/development/-/ai/anatomy-of-a-portlet

// Those jars are loaded at parents classloaders, 
// and causes silent portlet deployment failure if included.
eventCreateWarStart = { warName, stagingDir ->
   ant.delete(failonerror: false) {
      fileset(dir: "${stagingDir}/WEB-INF/lib") {
         include(name: "servlet-api*.jar")
         include(name: "portal-kernel*.jar")
         include(name: "portal-service*.jar")
         include(name: "portlet-api*.jar")
         include(name: "jcl-over-slf4j*.jar")
         // include(name: "org.spring*3.0*.jar") // Already in LR 6
         // include(name: "spring-*.jar") // Already in LR 6
      }
   }
}

// Add portlet's xmls
eventPackagingEnd = {
   def searchPath = "file:${basedir}/grails-app/portlets/**/*Portlet.groovy"
   Resource[] portletFiles = resolveResources(searchPath).toList()
   generatePortletXml(portletFiles)
   generateLiferayDisplayXml(portletFiles)
   generateLiferayPortletXml(portletFiles)
   generateLiferayPluginPackageProperties()
}

Resource[] resolveResources(String pattern) {
   return new PathMatchingResourcePatternResolver().getResources(pattern)
}

def generatePortletXml(Resource[] portletFiles) {
   def portletXml = generatePortletConfigFile("portlet.xml")
   def xmlWriter = new StreamingMarkupBuilder()

   String portletVersion = '2.0'
   String underscoredVersion = portletVersion.replaceAll("\\.", "_")

   def xml = xmlWriter.bind {
      mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>'
      mkp.comment 'GENERATED BY GRAILS PORTLETS PLUGIN - DO NOT EDIT AND CONFIGURE IN PORTLET groovy'

      'portlet-app'(version: portletVersion,
         'xmlns': "http://java.sun.com/xml/ns/portlet/portlet-app_${underscoredVersion}.xsd",
         'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
         'xsi:schemaLocation': "http://java.sun.com/xml/ns/portlet/portlet-app_${underscoredVersion}.xsd") {

         portletFiles.each {portletClassFile ->
            String className = getPortletClassName(portletClassFile.getFile().getAbsolutePath())
            Class portletClass = classLoader.loadClass(className)
            String portletName = portletClassFile.getFilename() - 'Portlet.groovy'
            def instance = portletClass.newInstance()
            checkRequiredProperties(['supports', 'title', 'displayName'], instance)

            "portlet" {
               'portlet-name'(portletName)
               'display-name'(instance.displayName)
               'portlet-class'('org.codehaus.grails.portlets.GrailsDispatcherPortlet')
               'init-param' {
                  'name'('contextClass')
                  'value'('org.codehaus.grails.portlets.GrailsPortletApplicationContext')
               }
               'init-param' {
                  'name'("grailsPortletClass")
                  'value'(className)
               }
               'init-param' {
                  'name'('contextConfigLocation')
                  'value'('/WEB-INF/portlet-context.groovy')
               }
               instance.supports.each { mime, types ->
                  'supports' {
                     'mime-type'(mime)
                     types.each { mode ->
                        'portlet-mode'(mode)
                     }
                  }
               }
               'portlet-info' {
                  //TODO support 1l8n via properties files to supply these
                  'title'(instance.title)
                  if (hasProperty('shortTitle', instance)) {
                     'short-title'(instance.shortTitle)
                  }
                  if (hasProperty('keywords', instance)) {
                     'keywords'(instance.keywords)
                  }
               }
               getConfiguredMappers().each { role ->
                  'security-role-ref' {
                     'role-name'(role.key)
                  }
               }
               if (hasProperty('events', instance)) {
                  instance.events.publish.each { event ->
                     'supported-publishing-event' {
                        'name'(event)
                     }
                  }
                  instance.events.process?.each { event ->
                     'supported-processing-event' {
                        'name'(event)
                     }
                  }
               }
               if (hasProperty('public_render_params', instance)) {
                  instance.public_render_params.each { prp ->
                     'supported-public-render-parameter'(prp)
                  }
               }
            }
         }
         //add any defined events
         if (config.liferay.events) {
            config.liferay.events.each { event ->
               "event-definition" {
                  "name"(event.key)
                  if (event.value?.type) {
                     "value-type"(event.value.type)
                  }
               }
            }
         }
         //add any defined public render parameters
         if (config.liferay.public_render_parameters) {
            config.liferay.public_render_parameters.each { prp ->
               "public-render-parameter" {
                  "identifier"(prp.key)
                  "name"(prp.value)
               }
            }
         }
      }
   }

   portletXml.write(xml.toString())
   copySpringConfig()
}

def generateLiferayDisplayXml(Resource[] portletFiles) {
   def liferayDisplayXml = generatePortletConfigFile("liferay-display.xml")

   def xmlWriter = new StreamingMarkupBuilder()

   def xml = xmlWriter.bind {
      mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>'
      mkp.yieldUnescaped '<!DOCTYPE display PUBLIC "-//Liferay//DTD Display 5.2.0//EN" "http://www.liferay.com/dtd/liferay-display_5_2_0.dtd">'
      mkp.comment 'GENERATED BY GRAILS PORTLETS PLUGIN - DO NOT EDIT AND CONFIGURE IN PORTLET groovy'

      def portletMap = [:]
      portletFiles.each { portletClassFile ->
         String className = getPortletClassName(portletClassFile.getFile().getAbsolutePath())
         Class portletClass = classLoader.loadClass(className)
         String portletName = portletClassFile.getFilename() - 'Portlet.groovy'
         def instance = portletClass.newInstance()
         if (hasProperty('liferay_display_category', instance)) {
            portletMap[instance.liferay_display_category] = [portletName] + (portletMap[instance.liferay_display_category] ?: [])
         } else {
            // Default category
            portletMap["category.sample"] = [portletName] + (portletMap["category.sample"] ?: [])
         }
      }

      'display' {
         portletMap.each { k, v ->
            'category'(name: k) {
               v.each { p ->
                  'portlet'(id: p)
               }
            }
         }
      }
   }
   liferayDisplayXml.write(xml.toString())
}

def generateLiferayPortletXml(portletFiles) {

   def attribs = [:]
   if (config.liferay.portlet_custom_user_attributes) {
      attribs = config.liferay.portlet_custom_user_attributes
      assert (attribs instanceof Map)
   }

   def liferayPortletXml = generatePortletConfigFile("liferay-portlet.xml")
   def xmlWriter = new StreamingMarkupBuilder()
   def xml = xmlWriter.bind {
      mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>'
      mkp.yieldUnescaped '<!DOCTYPE liferay-portlet-app PUBLIC "-//Liferay//DTD Portlet Application 4.3.3//EN" "http://www.liferay.com/dtd/liferay-portlet-app_4_3_3.dtd">'
      mkp.comment 'GENERATED BY GRAILS PORTLETS LIFERAY PLUGIN - DO NOT EDIT THIS FILE.'
      'liferay-portlet-app' {
         portletFiles.each {portletClassFile ->
            String className = getPortletClassName(portletClassFile.file.absolutePath)
            Class portletClass = classLoader.loadClass(className)
            String portletName = portletClassFile.filename - 'Portlet.groovy'
            def instance = portletClass.newInstance()
            'portlet' {
               'portlet-name'(portletName)
               def fields = portletClass.getDeclaredFields()
               def dtd_portlet = [
                  'icon', 'virtual_path', 'struts_path',
                  'configuration_path', 'configuration_action_class', 'indexer_class',
                  'open_search_class', 'scheduler_class', 'portlet_url_class',
                  'friendly_url_mapper_class', 'url_encoder_class', 'portlet_data_handler_class',
                  'portlet_layout_listener_class', 'pop_message_listener_class',
                  'social_activity_interpreter_class', 'social_request_interpreter_class',
                  'preferences_company_wide', 'preferences_unique_per_layout',
                  'preferences_owned_by_group', 'use_default_template', 'show_portlet_access_denied',
                  'show_portlet_inactive', 'action_url_redirect', 'restore_current_view',
                  'maximize_edit', 'maximize_help', 'pop_up_print', 'layout_cacheable', 'instanceable',
                  'user_principal_strategy', 'private_request_attributes',
                  'private_session_attributes', 'render_weight', 'ajaxable', 'header_portal_css',
                  'header_portlet_css', 'header_portal_javascript', 'header_portlet_javascript',
                  'footer_portal_css', 'footer_portlet_css', 'footer_portal_javascript',
                  'footer_portlet_javascript', 'css_class_wrapper', 'facebook_integration',
                  'add_default_resource', 'system', 'active', 'include']

               dtd_portlet.each { elementName ->
                  def field = fields.find {
                     it.name == 'liferay_portlet_' + elementName
                  }
                  if (field) {
                     field.setAccessible(true)
                     def element = (field.name - 'liferay_portlet_').replace('_', '-')
                     if (field.get(instance) instanceof List) {
                        field.get(instance).each {
                           invokeMethod(element, it.toString())
                        }
                     } else {
                        invokeMethod(element, field.get(instance).toString())
                     }
                  }
               }
            }
         }
         getConfiguredMappers().each { role ->
            'role-mapper' {
               'role-name'(role.key)
               'role-link'(role.value)
            }
         }
         attribs.each { attrib ->
            'custom-user-attribute' {
               'name'(attrib.key)
               'custom-class'(attrib.value)
            }
         }
      }
   }
   liferayPortletXml.write(xml.toString())
}

def generateLiferayPluginPackageProperties() {
   def liferayPluginPackageProperties = generatePortletConfigFile("liferay-plugin-package.properties")
   if (config.liferay.get('plugin_package')) {
      def conf = config.liferay.get('plugin_package')
      def rconf = new ConfigObject()
      conf.each { key, value ->
         rconf += [(key.replace('_', '-')): (value)]
      }
      rconf.toProperties().store(liferayPluginPackageProperties.newOutputStream(),
         "This is generated by Grails. The changes will be overwritten. Edit 'liferay.grails-app/conf/Config.groovy.")
   }
}

def hasProperty(propertyName, instance) {
   try {
      def value = instance."${propertyName}"
      return true
   } catch (MissingPropertyException mpe) {
      return false
   }
}

def getPortletClassName(String filePath) {
   def withoutBasePath = filePath.substring("$basedir/grails-app/portlets".length() + 1)
   withoutBasePath.replaceAll('[\\\\/]', '.') - '.groovy'
}

def generatePortletConfigFile(String fileName) {
   def xml = new File("${basedir}/web-app/WEB-INF/${fileName}")
   if (xml.exists()) {
      xml.delete()
   }
   return xml
}

def checkRequiredProperties(propertyNames, instance) {
   propertyNames.each {
      if (!hasProperty(it, instance)) {
         throw new MissingPropertyException("${instance.class.name} does not have the required properties ${propertyNames}",
            instance.getClass())
      }
   }
}

def Map getConfiguredMappers() {
   Map mappers = [:]
   if (config.liferay.portlet_role_mappers) {
      mappers = config.liferay.portlet_role_mappers
      assert (mappers instanceof Map)
   } else {
      mappers = [administrator: 'Administrator', guest: 'Guest', 'power-user': 'Power User', user: 'User']
   }

   return mappers
}

def copySpringConfig() {
   def springConfigSource = "${portletsPluginDir}/src/templates/scripts/portlet-context.groovy"
   def springConfigDestination = "${basedir}/web-app/WEB-INF/portlet-context.groovy"
   if (!(new File(springConfigDestination).exists())) {
      ant.copy(file: springConfigSource, tofile: springConfigDestination)
   }
}
